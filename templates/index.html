<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Interactive Heatmap</title>

    <!-- Deck.gl -->
    <script src="https://unpkg.com/deck.gl@latest/dist.min.js"></script>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        html,
        body {
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: system-ui, -apple-system, sans-serif;
        }

        #map {
            height: 100%;
            width: 100%;
            position: relative;
        }

        .tooltip {
            position: absolute;
            padding: 0.75rem;
            background: rgba(17, 24, 39, 0.95);
            color: white;
            border-radius: 0.5rem;
            font-size: 0.875rem;
            pointer-events: none;
            z-index: 1000;
            box-shadow: 0 8px 25px -5px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            max-width: 320px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .tooltip-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.25rem;
        }

        .tooltip-label {
            color: #9CA3AF;
            margin-right: 1rem;
            font-weight: 500;
        }

        .tooltip-value {
            color: #F3F4F6;
            font-weight: 600;
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace;
        }

        .tooltip-header {
            color: #60A5FA;
            font-weight: 600;
            margin-bottom: 0.5rem;
            padding-bottom: 0.25rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        input[type="range"] {
            @apply h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            @apply appearance-none w-4 h-4 bg-blue-600 rounded-full;
        }

        .cursor-crosshair .deck-canvas {
            cursor: crosshair !important;
        }

        .cursor-crosshair .deck-canvas {
            pointer-events: all !important;
        }

        .controls-panel {
            position: fixed;
            top: 1rem;
            right: 1rem;
            background: white;
            padding: 1rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            width: 18rem;
            z-index: 1000;
        }

        /* Toggle switch styles */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 48px;
            height: 24px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #cbd5e1;
            transition: 0.3s;
            border-radius: 24px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }

        input:checked + .toggle-slider {
            background-color: #3b82f6;
        }

        input:checked + .toggle-slider:before {
            transform: translateX(24px);
        }

        .value-picker-active {
            background-color: #eff6ff !important;
            border-color: #3b82f6 !important;
        }

        .picked-value {
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
            padding: 0.75rem;
            border-radius: 0.5rem;
            margin-top: 1rem;
            font-size: 0.875rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        .copy-button {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .copy-button:hover {
            background: rgba(255, 255, 255, 0.3);
        }
    </style>
</head>

<body class="bg-gray-100 font-sans" 
      data-default-opacity="{{ config.DEFAULT_MAP_OPACITY }}"
      data-initial-radius="{{ config.INITIAL_HEATMAP_RADIUS }}"
      data-initial-intensity="{{ config.INITIAL_HEATMAP_INTENSITY }}"
      data-initial-threshold="{{ config.INITIAL_HEATMAP_THRESHOLD }}">
    <div id="map" class="relative"></div>
    
    <!-- Enhanced Tooltip -->
    <div id="tooltip" class="tooltip" style="display: none;">
        <!-- Content dynamically updated -->
    </div>

    <!-- Controls Panel -->
    <div class="controls-panel">
        <div class="space-y-4">
            <!-- Value Picker Toggle -->
            <div class="bg-gray-50 p-3 rounded-lg border">
                <div class="flex items-center justify-between mb-2">
                    <label class="text-sm font-medium text-gray-700">Value Picker</label>
                    <label class="toggle-switch">
                        <input type="checkbox" id="valuePickerToggle">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <p class="text-xs text-gray-500">Click on the map to get precise values</p>
                <div id="pickedValueDisplay" style="display: none;" class="picked-value">
                    <div class="flex items-center justify-between mb-1">
                        <span class="font-medium">Picked Value</span>
                        <button class="copy-button" id="copyValueBtn">Copy</button>
                    </div>
                    <div id="pickedValueContent"></div>
                </div>
            </div>

            <!-- Existing Controls -->
            <div>
                <label class="flex items-center justify-between text-sm font-medium text-gray-700 mb-2">
                    Layer Opacity
                    <span id="opacityValue" class="text-blue-600">{{ config.DEFAULT_MAP_OPACITY }}</span>
                </label>
                <input type="range" id="opacitySlider" min="0" max="1" step="0.01" value="{{ config.DEFAULT_MAP_OPACITY }}" class="w-full" />
            </div>
            <div>
                <label class="flex items-center justify-between text-sm font-medium text-gray-700 mb-2">
                    Radius
                    <span id="radiusValue" class="text-blue-600">{{ config.INITIAL_HEATMAP_RADIUS }}px</span>
                </label>
                <input type="range" id="radiusSlider" min="1" max="100" step="1" value="{{ config.INITIAL_HEATMAP_RADIUS }}" class="w-full" />
            </div>
            <div>
                <label class="flex items-center justify-between text-sm font-medium text-gray-700 mb-2">
                    Intensity
                    <span id="intensityValue" class="text-blue-600">{{ "%.1f"|format(config.INITIAL_HEATMAP_INTENSITY|float) }}</span>
                </label>
                <input type="range" id="intensitySlider" min="0" max="5" step="0.1" value="{{ config.INITIAL_HEATMAP_INTENSITY }}" class="w-full" />
            </div>
            <div>
                <label class="flex items-center justify-between text-sm font-medium text-gray-700 mb-2">
                    Threshold
                    <span id="thresholdValue" class="text-blue-600">{{ "%.2f"|format(config.INITIAL_HEATMAP_THRESHOLD|float) }}</span>
                </label>
                <input type="range" id="thresholdSlider" min="0" max="1" step="0.01" value="{{ config.INITIAL_HEATMAP_THRESHOLD }}" class="w-full" />
            </div>
        </div>
    </div>

    <!-- Help Icon and Tooltip -->
    <div class="group absolute bottom-4 left-4 z-[1000]">
        <button id="helpIcon"
            class="w-10 h-10 bg-blue-500 text-white rounded-full flex items-center justify-center shadow-lg hover:bg-blue-600 transition-colors focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50">
            <span class="text-xl font-bold">?</span>
        </button>
        <div id="helpTooltip"
            class="absolute bottom-full left-0 mb-2 w-64 bg-gray-800 text-white text-xs rounded-md shadow-xl p-3 opacity-0 group-hover:opacity-100 transition-opacity duration-300 pointer-events-none">
            <h4 class="font-semibold text-sm mb-1">Controls Help:</h4>
            <ul class="list-disc list-inside space-y-1">
                <li><strong>Value Picker:</strong> Toggle to enable precise value picking. Click on data points to get exact coordinates and values.</li>
                <li><strong>Layer Opacity:</strong> Adjusts the transparency of the heatmap layer.</li>
                <li><strong>Radius:</strong> Controls the radius of influence for each data point in pixels.</li>
                <li><strong>Intensity:</strong> Multiplies the weight of each data point.</li>
                <li><strong>Threshold:</strong> Sets the minimum normalized value a point must have to be drawn.</li>
            </ul>
            <div class="absolute left-1/2 bottom-0 transform -translate-x-1/2 translate-y-full w-3 h-3 bg-gray-800 rotate-45"></div>
        </div>
    </div>

    <script>
        // Get configuration values from HTML data attributes
        const bodyElement = document.body;
        const appConfig = {
            defaultMapOpacity: parseFloat(bodyElement.dataset.defaultOpacity),
            initialHeatmapRadius: parseInt(bodyElement.dataset.initialRadius),
            initialHeatmapIntensity: parseFloat(bodyElement.dataset.initialIntensity),
            initialHeatmapThreshold: parseFloat(bodyElement.dataset.initialThreshold)
        };

        // Initialize deck.gl
        let deckgl;
        let heatmapLayer;
        let dataPointsLayer;
        let data = [];
        let valueRange = { min: 0, max: 1 };
        let colorScale = [];
        let currentOpacity = appConfig.defaultMapOpacity;
        let valuePickerMode = false;
        let hoveredObject = null;
        let pickedValue = null;

        // Configuration for the heatmap
        let heatmapConfig = { 
            radius: appConfig.initialHeatmapRadius,
            intensity: appConfig.initialHeatmapIntensity,
            threshold: appConfig.initialHeatmapThreshold
        };

        // OpenStreetMap tile layer configuration
        const OSM_TILE_LAYER = {
            id: 'osm-tiles',
            type: 'TileLayer',
            data: 'https://tile.openstreetmap.org/{z}/{x}/{y}.png',
            tileSize: 256,
            minZoom: 0,
            maxZoom: 19,
            renderSubLayers: props => {
                const {
                    bbox: { west, south, east, north }
                } = props.tile;

                return new deck.BitmapLayer({
                    id: props.id,
                    data: null,
                    image: props.data,
                    bounds: [west, south, east, north]
                });
            }
        };

        // Helper function to convert hex to RGB
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        // Create heatmap layer
        function createHeatmapLayer() {
            const colorRangeRGB = colorScale.map(([_, hexColor]) => {
                const rgb = hexToRgb(hexColor);
                return [rgb.r, rgb.g, rgb.b];
            });

            return new deck.HeatmapLayer({
                id: 'heatmap',
                data,
                getPosition: d => [d.Longitude, d.Latitude],
                getWeight: d => {
                    const normalizedValue = (d.Value - valueRange.min) / (valueRange.max - valueRange.min);
                    return normalizedValue;
                },
                radiusPixels: heatmapConfig.radius,
                intensity: heatmapConfig.intensity,
                threshold: heatmapConfig.threshold,
                colorRange: colorRangeRGB,
                opacity: currentOpacity,
                pickable: false,
                parameters: {
                    depthTest: false
                }
            });
        }

        // Create invisible data points layer for precise picking
        function createDataPointsLayer() {
            return new deck.ScatterplotLayer({
                id: 'data-points',
                data,
                getPosition: d => [d.Longitude, d.Latitude],
                getRadius: 3,
                getFillColor: [255, 255, 255, 0], // Invisible
                getLineColor: [255, 255, 255, 0], // Invisible
                pickable: true,
                visible: valuePickerMode,
                radiusUnits: 'pixels',
                radiusMinPixels: 3,
                radiusMaxPixels: 10,
                parameters: {
                    depthTest: false
                }
            });
        }

        // Update all layers
        function updateLayers() {
            const layers = [new deck.TileLayer(OSM_TILE_LAYER)];
            
            if (heatmapLayer) {
                heatmapLayer = createHeatmapLayer();
                layers.push(heatmapLayer);
            }
            
            if (dataPointsLayer) {
                dataPointsLayer = createDataPointsLayer();
                layers.push(dataPointsLayer);
            }
            
            deckgl.setProps({ layers });
        }

        // Format number with appropriate precision
        function formatValue(value) {
            if (typeof value !== 'number') return value;
            return value.toLocaleString(undefined, { 
                minimumFractionDigits: 2, 
                maximumFractionDigits: 6 
            });
        }

        // Show tooltip with object information
        function showTooltip(object, x, y) {
            const tooltip = document.getElementById('tooltip');
            if (!object) {
                tooltip.style.display = 'none';
                return;
            }

            const normalizedValue = (object.Value - valueRange.min) / (valueRange.max - valueRange.min);
            
            tooltip.innerHTML = `
                <div class="tooltip-header">${valuePickerMode ? 'Data Point Details' : 'Hover Information'}</div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Latitude:</span>
                    <span class="tooltip-value">${formatValue(object.Latitude)}</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Longitude:</span>
                    <span class="tooltip-value">${formatValue(object.Longitude)}</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Value:</span>
                    <span class="tooltip-value">${formatValue(object.Value)}</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Normalized:</span>
                    <span class="tooltip-value">${formatValue(normalizedValue)}</span>
                </div>
                ${object.Bathy ? `
                <div class="tooltip-row">
                    <span class="tooltip-label">Bathymetry:</span>
                    <span class="tooltip-value">${object.Bathy}</span>
                </div>
                ` : ''}
                ${valuePickerMode ? '<div style="margin-top: 0.5rem; font-size: 0.75rem; color: #9CA3AF;">Click to pin this value</div>' : ''}
            `;

            tooltip.style.display = 'block';
            tooltip.style.left = `${x + 10}px`;
            tooltip.style.top = `${y - 10}px`;

            // Keep tooltip on screen
            const rect = tooltip.getBoundingClientRect();
            if (rect.right > window.innerWidth) {
                tooltip.style.left = `${x - rect.width - 10}px`;
            }
            if (rect.bottom > window.innerHeight) {
                tooltip.style.top = `${y - rect.height - 10}px`;
            }
        }

        // Handle picked value display
        function displayPickedValue(object) {
            pickedValue = object;
            const display = document.getElementById('pickedValueDisplay');
            const content = document.getElementById('pickedValueContent');
            
            const normalizedValue = (object.Value - valueRange.min) / (valueRange.max - valueRange.min);
            
            content.innerHTML = `
                <div style="font-size: 0.75rem; line-height: 1.4;">
                    <div><strong>Lat:</strong> ${formatValue(object.Latitude)}</div>
                    <div><strong>Lon:</strong> ${formatValue(object.Longitude)}</div>
                    <div><strong>Value:</strong> ${formatValue(object.Value)}</div>
                    <div><strong>Norm:</strong> ${formatValue(normalizedValue)}</div>
                </div>
            `;
            
            display.style.display = 'block';
            
            // Log to console for debugging
            console.log('Picked value:', {
                latitude: object.Latitude,
                longitude: object.Longitude,
                value: object.Value,
                normalized: normalizedValue
            });
        }

        // Copy picked value to clipboard
        function copyPickedValue() {
            if (!pickedValue) return;
            
            const normalizedValue = (pickedValue.Value - valueRange.min) / (valueRange.max - valueRange.min);
            const text = `Latitude: ${pickedValue.Latitude}\nLongitude: ${pickedValue.Longitude}\nValue: ${pickedValue.Value}\nNormalized: ${normalizedValue}`;
            
            navigator.clipboard.writeText(text).then(() => {
                const btn = document.getElementById('copyValueBtn');
                const originalText = btn.textContent;
                btn.textContent = 'Copied!';
                setTimeout(() => btn.textContent = originalText, 1000);
            }).catch(err => {
                console.error('Failed to copy: ', err);
            });
        }

        // Toggle value picker mode
        function toggleValuePickerMode() {
            valuePickerMode = !valuePickerMode;
            const mapContainer = document.getElementById('map');
            const toggle = document.getElementById('valuePickerToggle');
            const controlsPanel = document.querySelector('.controls-panel');
            
            if (valuePickerMode) {
                mapContainer.classList.add('cursor-crosshair');
                controlsPanel.querySelector('.bg-gray-50').classList.add('value-picker-active');
            } else {
                mapContainer.classList.remove('cursor-crosshair');
                controlsPanel.querySelector('.bg-gray-50').classList.remove('value-picker-active');
                document.getElementById('tooltip').style.display = 'none';
                document.getElementById('pickedValueDisplay').style.display = 'none';
            }
            
            updateLayers();
        }

        // Initialize the map
        function initializeMap() {
            deckgl = new deck.DeckGL({
                container: 'map',
                initialViewState: {
                    longitude: 0,
                    latitude: 0,
                    zoom: 2,
                    pitch: 0,
                    bearing: 0
                },
                controller: true,
                getCursor: ({ isDragging }) => {
                    if (valuePickerMode && !isDragging) return 'crosshair';
                    return isDragging ? 'grabbing' : 'grab';
                },
                onHover: (info, event) => {
                    hoveredObject = info.object;
                    if (valuePickerMode && info.object) {
                        showTooltip(info.object, event.center.x, event.center.y);
                    } else {
                        document.getElementById('tooltip').style.display = 'none';
                    }
                },
                onClick: (info, event) => {
                    if (valuePickerMode && info.object) {
                        displayPickedValue(info.object);
                        showTooltip(info.object, event.center.x, event.center.y);
                    }
                },
                layers: [new deck.TileLayer(OSM_TILE_LAYER)]
            });
        }

        // Load data and create visualization
        function loadData() {
            fetch('/data')
                .then(response => response.json())
                .then(result => {
                    data = result.data;
                    valueRange = result.valueRange;
                    colorScale = result.colorScale;

                    console.log('Data loaded:', {
                        dataLength: data.length,
                        valueRange,
                        colorScaleLength: colorScale.length
                    });

                    const lats = data.map(d => d.Latitude);
                    const lons = data.map(d => d.Longitude);
                    const centerLat = (Math.min(...lats) + Math.max(...lats)) / 2;
                    const centerLon = (Math.min(...lons) + Math.max(...lons)) / 2;

                    heatmapLayer = createHeatmapLayer();
                    dataPointsLayer = createDataPointsLayer();

                    deckgl.setProps({
                        initialViewState: {
                            longitude: centerLon,
                            latitude: centerLat,
                            zoom: 5,
                            pitch: 0,
                            bearing: 0
                        },
                        layers: [new deck.TileLayer(OSM_TILE_LAYER), heatmapLayer, dataPointsLayer]
                    });
                })
                .catch(error => console.error('Error loading data:', error));
        }

        // Event listeners
        document.getElementById('valuePickerToggle').addEventListener('change', toggleValuePickerMode);
        document.getElementById('copyValueBtn').addEventListener('click', copyPickedValue);

        document.getElementById('radiusSlider').addEventListener('input', function (e) {
            heatmapConfig.radius = parseInt(e.target.value);
            document.getElementById('radiusValue').textContent = heatmapConfig.radius + 'px';
            updateLayers();
        });

        document.getElementById('intensitySlider').addEventListener('input', function (e) {
            heatmapConfig.intensity = parseFloat(e.target.value);
            document.getElementById('intensityValue').textContent = heatmapConfig.intensity.toFixed(1);
            updateLayers();
        });

        document.getElementById('thresholdSlider').addEventListener('input', function (e) {
            heatmapConfig.threshold = parseFloat(e.target.value);
            document.getElementById('thresholdValue').textContent = heatmapConfig.threshold.toFixed(2);
            updateLayers();
        });

        document.getElementById('opacitySlider').addEventListener('input', function (e) {
            currentOpacity = parseFloat(e.target.value);
            document.getElementById('opacityValue').textContent = currentOpacity.toFixed(2);
            updateLayers();
        });

        // Initialize the application
        initializeMap();
        loadData();

        // Initialize slider values from config
        document.getElementById('opacityValue').textContent = currentOpacity.toFixed(2);
        document.getElementById('opacitySlider').value = currentOpacity;
        document.getElementById('radiusValue').textContent = heatmapConfig.radius + 'px';
        document.getElementById('radiusSlider').value = heatmapConfig.radius;
        document.getElementById('intensityValue').textContent = heatmapConfig.intensity.toFixed(1);
        document.getElementById('intensitySlider').value = heatmapConfig.intensity;
        document.getElementById('thresholdValue').textContent = heatmapConfig.threshold.toFixed(2);
        document.getElementById('thresholdSlider').value = heatmapConfig.threshold;
    </script>
</body>

</html> 